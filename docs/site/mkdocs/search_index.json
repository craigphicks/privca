{
    "docs": [
        {
            "location": "/",
            "text": "Summary\n\n\n\n\nThis document decribes a simple step-by-step configuration for configuring Client Side Authentification in the case of \nlighttpd v1.4.45\n as server, and Firebox Browser v65.0 as client.\nClient Side Authentification is part of \n\n\n\n\n\n\n\n\nBackground: What are \"two-way authentication\" and \"private CA\"?\n\n\n\n\nOne-way authentication is the most familiar model: that's the system of provable trust that allows the green lock followed by \nhttps://...\n to be displayed in the browser address bar.  The magic of \npublic cryptography\n makes possible the system whereby a client requests a URL, and then receives authentication data from a server saying \"I am the one allowed to serve this URL\", and it is believable because a CA (certificate authority) will vouch for it.  Of course the response URL had better match the requested URL -  otherwise you may be p*wned!\n\n\nTwo way authentication is an additional step where the server also receives authentication data from the client.  However, there are some subtle differences.  Firstly, instead of a URL it is an ID which is being verified.  Secondly,  the server does not request the ID first - the client initiates contact and then the server verifies that the client ID is on a list of allowed clients.  Nevertheless, the core algorithms behind authenticating the ID and authenticating the URL are the same, and most (but not all) of the procedural glue is the same.  This additional step is also called \"client side verification\"\n\n\nLast but not least, two-way authentication is for situations where the servers and clients which will be communicating with each other are known in advance at the time the certificates are issued.  Therefore two-way authentication is not applicable to general public browsing.  Two-way authentication is a niche use case for secure, closed membership systems.\n\n\nA private CA is also created for use on a secure, closed membership system.  A private CA is not globally known.  A private CA and two-way authentication are well suited to each other because they handle the same niche use case.\n\n\n\n\n\n\n\n\n\nlighttpd\n documentation on two-way security\n\n\n\n\nThe lighttpd \nSSL documentation\n\ndescribes the relevant parameters for one-way authentication:\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nssl.engine\n\n\nenable/disable ssl engine\n\n\n\n\n\n\nssl.pemfile\n\n\npath to the PEM file for SSL support (must contain both certificate and private key)\n\n\n\n\n\n\nssl.ca-file\n\n\npath to the CA file for support of chained certificates\n\n\n\n\n\n\n\n\nThe additional parameters for two-way authentication, i.e. \"Client Side Verification\", are also described:\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nssl.verifyclient.activate\n\n\nenable/disable client verification\n\n\n\n\n\n\nssl.verifyclient.enforce\n\n\nenable/disable enforcing client verification\n\n\n\n\n\n\nssl.verifyclient.depth\n\n\ncertificate depth for client verification\n\n\n\n\n\n\nssl.verifyclient.username\n\n\nclient certificate entity to export as env:REMOTE_USER (eg. SSL_CLIENT_S_DN_emailAddress, SSL_CLIENT_S_DN_UID, etc.)\n\n\n\n\n\n\n\n\nSearching with \nsite:redmine.lighttpd.net SSL_CLIENT_S_DN_C\n shows that\n\n\nssl.verifyclient.username = SSL_CLIENT_S_DN_CN\n\n\n\nis a valid value, and will make  the \"Common Name\" of the client certificate available.\n\n\nWe want to use this \"Common Name\" for authentification in the \nlighttpd\n server itself, not act upon the value in the application.  The \nMod_Auth documentation\n describes how to do this:\n\n\nauth.require = ( \"\" =>\n                 (\n                   \"method\"  => \"extern\",\n                   \"realm\"   => \"certificate\",\n                   \"require\" => \"user=agent007|user=agent008\" \n                 )\n               )\n\n\n\n\nPutting all this information together will be covered in\nsection \niwozere\n\n\n\n\n\n\n\n\n\n Full example with \nlighttpd v1.4.45\n and \nFirefox v65.0\n\n\n\n\n\n\nstep 1\n\n\n\n\nCreate one private root and two leaf certificates with the following profiles:\n\n\n\n\n\n\n\n\nProperty\n\n\nCA cert\n\n\nServer cert\n\n\nClient cert\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nCA\n\n\nLeaf\n\n\nLeaf\n\n\n\n\n\n\nCN (common name)\n\n\nRoot1\n\n\nServer1\n\n\nClient1\n\n\n\n\n\n\nsubjectAltName\n\n\nN/A\n\n\nDNS:pihole.home.lan,\nDNS:pihole,IP:192.168.1.20\n\n\nN/A\n\n\n\n\n\n\nKey filename\n\n\nRoot1.key\n\n\nServer1.key\n\n\nClient1.key\n\n\n\n\n\n\nCert filname\n\n\nRoot1.crt\n\n\nServer1.crt\n\n\nClient1.crt\n\n\n\n\n\n\nKey+Cert filename\n\n\nN/A\n\n\nServer1.key-crt.pem\n\n\nClient1.p12\n\n\n\n\n\n\n\n\nNote:\n The field \nDNS:pihole.home.lan,DNS:pihole,IP:192.168.1.20\n\nis a single string with no spaces. It was broken into two lines only to fit in the table.\n\n\nThere are a number of programs capable for creating such files, but for convenience and brevity\na humble minimalist batch file calling making \nopenssl\n calls is provided with this document.\nIt is described in the section \nprivca\n Cert Creation Tool\n.\n\n\n\n\n\nPause for Bird's Eye View\n\n\n\n\nWe pause for a birds eye view of what files go where, and what role they\nplay in the web of Authentication.\n\n\nThe key+cert files are composed as follows:\n\n\n\n\n\n\n\n\n\u00a0\n\n\nKey Part source file\n\n\nCert Part source file\n\n\nCombined File\n\n\n\n\n\n\n\n\n\n\nServer\n\n\nServer1.key\n\n\nServer1.crt\n\n\nServer1.key-crt.pem\n\n\n\n\n\n\nClient\n\n\nClient1.key\n\n\nClient1.crt\n\n\nClient1.p12\n\n\n\n\n\n\n\n\nThe next table shows to where the files will eventually be exported and the role they will play:\n\n\n\n\n\n\n\n\nAuthenticator\n\n\nAuthenticatee\n\n\nServer side file\n\n\nClient side file\n\n\n\n\n\n\n\n\n\n\nClient\n\n\nServer\n\n\nServer1.key-crt.pem\n\n\nRoot1.crt\n\n\n\n\n\n\nSever\n\n\nClient\n\n\nRoot1.crt\n\n\nClient1.p12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstep 6\n\n\n\nFrom Firefox -\n\n\nClick through\n\n\nPreferences | Privacy & Security | View Certificates | Authorities | Import\n\n\n\n\nto upload\n\n\n./export/ca/public/HomeLan.crt\n\n\n\n\nThen click through\n\n\nPreferences | Privacy & Security | View Certificates | Your Certificates | Import\n\n\n\n\nto upload\n\n\n./export/private/Client1--HomeLan.p12\n\n\n\n\nWhen uploading, Firefox will ask you for the password you set when creating it, if any.\n\n\n\n\n\n\n\nstep 7\n\n\n\nCopy files to the serving device running \nlighttpd\n -\n\n\n\n\n\n\n\n\nSource\n\n\nDest Dir\n\n\n\n\n\n\n\n\n\n\n./export/ca/public/HomeLan.crt\n\n\n/etc/lighttpd/ssl/public/\n\n\n\n\n\n\n./export/private/PiSrv-HomeLan.key-crt.pem\n\n\n/etc/lighttpd/ssl/private/\n\n\n\n\n\n\n\n\n(The destinations can be freely chosen, this is just an example).\n\n\nSet the destination owner and permission as follows - \n\n\n\n\n\n\n\n\nDir or File\n\n\nowner:group\n\n\nperm\n\n\n\n\n\n\n\n\n\n\n/etc/lighttpd/ssl/public/\n\n\nroot:www-data\n\n\n755\n\n\n\n\n\n\n/etc/lighttpd/ssl/public/HomeLan.crt\n\n\nroot:www-data\n\n\n644\n\n\n\n\n\n\n/etc/lighttpd/ssl/private/\n\n\nroot:www-data\n\n\n750\n\n\n\n\n\n\n/etc/lighttpd/ssl/private/PiSrv-HomeLan.key-crt.pem\n\n\nroot:www-data\n\n\n640\n\n\n\n\n\n\n\n\nThese settings allow read access by \nwww-data\n when serving.\n\n\n\n\n\n\n\nstep 8\n\n\n\nConfigure an existing \nlighttpd\n configuration file where it configures the \nhttps\n port \n443\n.\nThis might be in a file \n/etc/lighttpd/external.conf\n.\n\n\nIn the case that \nlighttpd\n is already configured for \nhttps\n one-way authentication, then modify/add the following parameter settings to achieve our two-way authentication:\n\n\n  $SERVER[\"socket\"] == \":443\" {\n    ...\n    ssl.pemfile = \"/etc/lighttpd/ssl/private/PiSrv--HomeLan.key-crt.pem\"\n    ssl.ca-file =  \"/etc/lighttpd/ssl/public/HomeLan.crt\"\n    ...\n    ssl.verifyclient.activate = \"enable\"\n    ssl.verifyclient.enforce = \"enable\"\n    ssl.verifyclient.depth = \"2\"\n    ssl.verifyclient.username = \"SSL_CLIENT_S_DN_CN\"\n    }\n\n\n\n\nIn the case that \nlighttpd\n is not yet configured for \nhttps\n one-way authentication, then here is an example of settings for \nhttps\n two-way authentication:\n\n\n$HTTP[\"host\"] =~ \"pihole($|\\.home\\.lan)\" {\n  # Ensure the Pi-hole Block Page knows that this is not a blocked domain\n  # PIHOLE APPLICATION SPECIFIC - ignore otherwise\n  #setenv.add-environment = (\"fqdn\" => \"true\")\n\n  # Enable the SSL engine with a LE cert, only for this specific host\n  $SERVER[\"socket\"] == \":443\" {\n    ssl.engine = \"enable\"\n    ssl.pemfile = \"/etc/lighttpd/ssl/PiSrv--HomeLan.key-crt.pem\"\n    ssl.ca-file =  \"/etc/lighttpd/ssl/public/HomeLan.crt\"\n    ssl.honor-cipher-order = \"enable\"\n    ssl.cipher-list = \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\"\n    ssl.use-sslv2 = \"disable\"\n    ssl.use-sslv3 = \"disable\"\n    # client side authentification       \n    ssl.verifyclient.activate = \"enable\"\n    ssl.verifyclient.enforce = \"enable\"\n    ssl.verifyclient.depth = \"10\"\n    ssl.verifyclient.username = \"SSL_CLIENT_S_DN_CN\"\n###    ssl.verifyclient.username = \"SSL_CLIENT_S_DN_emailAddress\"\n    }\n\n  # Redirect HTTP to HTTPS\n  $HTTP[\"scheme\"] == \"http\" {\n    $HTTP[\"host\"] =~ \".*\" {\n      url.redirect = (\".*\" => \"https://%0$0\")\n    }\n  }\n}\n\n\n\n\nNote: The above two-way setting were adapted from\n[these one-way settings using an LE cert]\n(https://discourse.pi-hole.net/t/enabling-https-for-your-pi-hole-web-interface/5771).\n\n\n\n\n\n\n\n\nstep 9\n\n\n\nNow create a new additional \nlighttpd\n configuration file\n\n\nsudo nano /etc/lighttpd/conf-available/02-auth-cert.conf\n\n\n\n\nwith content\n\n\n# comment out the next line to silence warnings if \"mod_auth\" already loaded\nserver.modules += (\"mod_auth\")\nauth.require = ( \"\" =>\n                 (\n                   \"method\"  => \"extern\",\n                   \"realm\"   => \"certificate\",\n                   \"require\" => \"user=Client1--HomeLan\" \n                 )\n               )\n\n\n\n\nNote: To allow multiple client IDs, separate by \n|\n and prefix each ID with `user=\", e.g.,:\n\n\n                   \"require\" => \"user=Client1--HomeLan|user=Client2--HomeLan\" \n\n\n\n\n\n\n\n\n\n\n\nstep 10\n\n\n\nRestart the lighttpd daemon -\n\n\nsystemctl restart lighttpd\n\n\n\n\nor\n\n\nservice lighttpd restart\n\n\n\n\nCheck the status is OK -\n\n\nsystemctl status lighttpd\n\n\n\n\nor\n\n\nservice lighttpd status\n\n\n\n\n\n\n\n\n\n\n\nstep 11\n\n\n\nTest access of the server from the Firefox browser, e.g., enter the address \npihole.home.lan\n or \n192.168.1.20\n into the address bar.  On the first access Firefox will put up a dialog box for you to confirm the client certificate \nClient1--HomeLan.p12\n.  If you don't see the dialog box hunt around for it.  I once found it in another workspace under an already existing window.\n\n\n\n\n\n\n\n\nstep 12\n\n\n\nAdd more clients and servers to the network using the same CA, if required.",
            "title": "Home"
        },
        {
            "location": "/#summary",
            "text": "This document decribes a simple step-by-step configuration for configuring Client Side Authentification in the case of  lighttpd v1.4.45  as server, and Firebox Browser v65.0 as client.\nClient Side Authentification is part of",
            "title": "Summary"
        },
        {
            "location": "/#background-what-are-two-way-authentication-and-private-ca",
            "text": "One-way authentication is the most familiar model: that's the system of provable trust that allows the green lock followed by  https://...  to be displayed in the browser address bar.  The magic of  public cryptography  makes possible the system whereby a client requests a URL, and then receives authentication data from a server saying \"I am the one allowed to serve this URL\", and it is believable because a CA (certificate authority) will vouch for it.  Of course the response URL had better match the requested URL -  otherwise you may be p*wned!  Two way authentication is an additional step where the server also receives authentication data from the client.  However, there are some subtle differences.  Firstly, instead of a URL it is an ID which is being verified.  Secondly,  the server does not request the ID first - the client initiates contact and then the server verifies that the client ID is on a list of allowed clients.  Nevertheless, the core algorithms behind authenticating the ID and authenticating the URL are the same, and most (but not all) of the procedural glue is the same.  This additional step is also called \"client side verification\"  Last but not least, two-way authentication is for situations where the servers and clients which will be communicating with each other are known in advance at the time the certificates are issued.  Therefore two-way authentication is not applicable to general public browsing.  Two-way authentication is a niche use case for secure, closed membership systems.  A private CA is also created for use on a secure, closed membership system.  A private CA is not globally known.  A private CA and two-way authentication are well suited to each other because they handle the same niche use case.",
            "title": "Background: What are \"two-way authentication\" and \"private CA\"?"
        },
        {
            "location": "/#lighttpd-documentation-on-two-way-security",
            "text": "The lighttpd  SSL documentation \ndescribes the relevant parameters for one-way authentication:     Option  Description      ssl.engine  enable/disable ssl engine    ssl.pemfile  path to the PEM file for SSL support (must contain both certificate and private key)    ssl.ca-file  path to the CA file for support of chained certificates     The additional parameters for two-way authentication, i.e. \"Client Side Verification\", are also described:     Option  Description      ssl.verifyclient.activate  enable/disable client verification    ssl.verifyclient.enforce  enable/disable enforcing client verification    ssl.verifyclient.depth  certificate depth for client verification    ssl.verifyclient.username  client certificate entity to export as env:REMOTE_USER (eg. SSL_CLIENT_S_DN_emailAddress, SSL_CLIENT_S_DN_UID, etc.)     Searching with  site:redmine.lighttpd.net SSL_CLIENT_S_DN_C  shows that  ssl.verifyclient.username = SSL_CLIENT_S_DN_CN  is a valid value, and will make  the \"Common Name\" of the client certificate available.  We want to use this \"Common Name\" for authentification in the  lighttpd  server itself, not act upon the value in the application.  The  Mod_Auth documentation  describes how to do this:  auth.require = ( \"\" =>\n                 (\n                   \"method\"  => \"extern\",\n                   \"realm\"   => \"certificate\",\n                   \"require\" => \"user=agent007|user=agent008\" \n                 )\n               )  Putting all this information together will be covered in\nsection  iwozere",
            "title": "lighttpd documentation on two-way security"
        },
        {
            "location": "/#step-1",
            "text": "Create one private root and two leaf certificates with the following profiles:     Property  CA cert  Server cert  Client cert      type  CA  Leaf  Leaf    CN (common name)  Root1  Server1  Client1    subjectAltName  N/A  DNS:pihole.home.lan, DNS:pihole,IP:192.168.1.20  N/A    Key filename  Root1.key  Server1.key  Client1.key    Cert filname  Root1.crt  Server1.crt  Client1.crt    Key+Cert filename  N/A  Server1.key-crt.pem  Client1.p12     Note:  The field  DNS:pihole.home.lan,DNS:pihole,IP:192.168.1.20 \nis a single string with no spaces. It was broken into two lines only to fit in the table.  There are a number of programs capable for creating such files, but for convenience and brevity\na humble minimalist batch file calling making  openssl  calls is provided with this document.\nIt is described in the section  privca  Cert Creation Tool .",
            "title": "step 1"
        },
        {
            "location": "/#pause-for-birds-eye-view",
            "text": "We pause for a birds eye view of what files go where, and what role they\nplay in the web of Authentication.  The key+cert files are composed as follows:     \u00a0  Key Part source file  Cert Part source file  Combined File      Server  Server1.key  Server1.crt  Server1.key-crt.pem    Client  Client1.key  Client1.crt  Client1.p12     The next table shows to where the files will eventually be exported and the role they will play:     Authenticator  Authenticatee  Server side file  Client side file      Client  Server  Server1.key-crt.pem  Root1.crt    Sever  Client  Root1.crt  Client1.p12",
            "title": "Pause for Bird's Eye View"
        },
        {
            "location": "/#step-6",
            "text": "From Firefox -  Click through  Preferences | Privacy & Security | View Certificates | Authorities | Import  to upload  ./export/ca/public/HomeLan.crt  Then click through  Preferences | Privacy & Security | View Certificates | Your Certificates | Import  to upload  ./export/private/Client1--HomeLan.p12  When uploading, Firefox will ask you for the password you set when creating it, if any.",
            "title": "step 6"
        },
        {
            "location": "/#step-7",
            "text": "Copy files to the serving device running  lighttpd  -     Source  Dest Dir      ./export/ca/public/HomeLan.crt  /etc/lighttpd/ssl/public/    ./export/private/PiSrv-HomeLan.key-crt.pem  /etc/lighttpd/ssl/private/     (The destinations can be freely chosen, this is just an example).  Set the destination owner and permission as follows -      Dir or File  owner:group  perm      /etc/lighttpd/ssl/public/  root:www-data  755    /etc/lighttpd/ssl/public/HomeLan.crt  root:www-data  644    /etc/lighttpd/ssl/private/  root:www-data  750    /etc/lighttpd/ssl/private/PiSrv-HomeLan.key-crt.pem  root:www-data  640     These settings allow read access by  www-data  when serving.",
            "title": "step 7"
        },
        {
            "location": "/#step-8",
            "text": "Configure an existing  lighttpd  configuration file where it configures the  https  port  443 .\nThis might be in a file  /etc/lighttpd/external.conf .  In the case that  lighttpd  is already configured for  https  one-way authentication, then modify/add the following parameter settings to achieve our two-way authentication:    $SERVER[\"socket\"] == \":443\" {\n    ...\n    ssl.pemfile = \"/etc/lighttpd/ssl/private/PiSrv--HomeLan.key-crt.pem\"\n    ssl.ca-file =  \"/etc/lighttpd/ssl/public/HomeLan.crt\"\n    ...\n    ssl.verifyclient.activate = \"enable\"\n    ssl.verifyclient.enforce = \"enable\"\n    ssl.verifyclient.depth = \"2\"\n    ssl.verifyclient.username = \"SSL_CLIENT_S_DN_CN\"\n    }  In the case that  lighttpd  is not yet configured for  https  one-way authentication, then here is an example of settings for  https  two-way authentication:  $HTTP[\"host\"] =~ \"pihole($|\\.home\\.lan)\" {\n  # Ensure the Pi-hole Block Page knows that this is not a blocked domain\n  # PIHOLE APPLICATION SPECIFIC - ignore otherwise\n  #setenv.add-environment = (\"fqdn\" => \"true\")\n\n  # Enable the SSL engine with a LE cert, only for this specific host\n  $SERVER[\"socket\"] == \":443\" {\n    ssl.engine = \"enable\"\n    ssl.pemfile = \"/etc/lighttpd/ssl/PiSrv--HomeLan.key-crt.pem\"\n    ssl.ca-file =  \"/etc/lighttpd/ssl/public/HomeLan.crt\"\n    ssl.honor-cipher-order = \"enable\"\n    ssl.cipher-list = \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\"\n    ssl.use-sslv2 = \"disable\"\n    ssl.use-sslv3 = \"disable\"\n    # client side authentification       \n    ssl.verifyclient.activate = \"enable\"\n    ssl.verifyclient.enforce = \"enable\"\n    ssl.verifyclient.depth = \"10\"\n    ssl.verifyclient.username = \"SSL_CLIENT_S_DN_CN\"\n###    ssl.verifyclient.username = \"SSL_CLIENT_S_DN_emailAddress\"\n    }\n\n  # Redirect HTTP to HTTPS\n  $HTTP[\"scheme\"] == \"http\" {\n    $HTTP[\"host\"] =~ \".*\" {\n      url.redirect = (\".*\" => \"https://%0$0\")\n    }\n  }\n}  Note: The above two-way setting were adapted from\n[these one-way settings using an LE cert]\n(https://discourse.pi-hole.net/t/enabling-https-for-your-pi-hole-web-interface/5771).",
            "title": "step 8"
        },
        {
            "location": "/#step-9",
            "text": "Now create a new additional  lighttpd  configuration file  sudo nano /etc/lighttpd/conf-available/02-auth-cert.conf  with content  # comment out the next line to silence warnings if \"mod_auth\" already loaded\nserver.modules += (\"mod_auth\")\nauth.require = ( \"\" =>\n                 (\n                   \"method\"  => \"extern\",\n                   \"realm\"   => \"certificate\",\n                   \"require\" => \"user=Client1--HomeLan\" \n                 )\n               )  Note: To allow multiple client IDs, separate by  |  and prefix each ID with `user=\", e.g.,:                     \"require\" => \"user=Client1--HomeLan|user=Client2--HomeLan\"",
            "title": "step 9"
        },
        {
            "location": "/#step-10",
            "text": "Restart the lighttpd daemon -  systemctl restart lighttpd  or  service lighttpd restart  Check the status is OK -  systemctl status lighttpd  or  service lighttpd status",
            "title": "step 10"
        },
        {
            "location": "/#step-11",
            "text": "Test access of the server from the Firefox browser, e.g., enter the address  pihole.home.lan  or  192.168.1.20  into the address bar.  On the first access Firefox will put up a dialog box for you to confirm the client certificate  Client1--HomeLan.p12 .  If you don't see the dialog box hunt around for it.  I once found it in another workspace under an already existing window.",
            "title": "step 11"
        },
        {
            "location": "/#step-12",
            "text": "Add more clients and servers to the network using the same CA, if required.",
            "title": "step 12"
        }
    ]
}